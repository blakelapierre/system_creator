<mathbox tabindex="2">
  <script type="mathbox/jsx">
    document.body.addEventListener('touchstart', goFullScreen);

    //bad name
    function goFullScreen() {
      if (document.body.requestFullscreen) document.body.requestFullscreen();
      else if (document.body.webkitRequestFullscreen) document.body.webkitRequestFullscreen();
      else if (document.body.mozRequestFullscreen) document.body.mozRequestFullscreen();
      else if (document.body.msRequestFullscreen) document.body.msRequestFullscreen();

      document.body.removeEventListener('touchstart', goFullScreen);
    }

/*
    window.addEventListener('beforeunload', event => {
      if (!localStorage) return console.log('No localStorage. Unable to save system!');

      if (simState.eventLog.length > 0) {
        const storage = JSON.parse(localStorage['systems'] || '[]');
        storage.push([new Date().getTime(), simState.eventLog]);
        localStorage.setItem('systems', JSON.stringify(storage));
      }
    });
*/

    if (localStorage && localStorage['saveOnExit'] === 'true')
      window.addEventListener('beforeunload', save);

    const thumbnailCanvas = document.createElement('canvas'),
          thumbnailContext = thumbnailCanvas.getContext('2d');

    thumbnailCanvas.height = 1;
    thumbnailCanvas.width = 100;

    function save() {
      if (!localStorage) return alert('No localStorage!');

      const {eventLog} = simState;

      if (eventLog.length === 0) return;

      const systems = JSON.parse(localStorage['systems'] || '[]');
      const thumbnail = createThumbnail(simState.eventLog, thumbnailContext, thumbnailCanvas);
      systems.push([new Date().getTime(), simState.eventLog, thumbnail]);
      localStorage['systems'] = JSON.stringify(systems);

      function createThumbnail(eventLog, context, canvas) {
        context.fillStyle = 'black';
        context.fillRect(0, 0, canvas.width, canvas.height);

        const max = eventLog[eventLog.length - 1][0]

        let currentBin = canvas.width,
            height = 0;

        for (let i = eventLog.length - 1; i >= 0; i--) {
          const [time, events] = eventLog[i],
                bin = Math.floor((time / max) * canvas.width);
  console.log(time, events);
          currentBin = bin;
          height = 0;

          const color = events.reduce((color, event, i) => {
                          const [type] = event;
  console.log(event, type);
                          if (type === 'newmass') {
                            const {color: massColor} = event[1];

                            console.log(massColor);

                            color[0] += massColor[0];
                            color[1] += massColor[1];
                            color[2] += massColor[2];
                            color[3] += massColor[3];
                          }

                          return color;
                        }, [0, 0, 0, 0]).map(component => component / events.length), // should weight by mass?
                [r, g, b, a] = color;

          context.fillStyle = `rgba(${Math.floor(r * 128)}, ${Math.floor(g * 128)}, ${Math.floor(b * 128)}, ${a})`;
          context.fillRect(bin, height, 1, 1);
        }

        return canvas.toDataURL();
      }
    }

    let simState = window.createSim(),
        {universe, positions, colors, sizes, eevents, uuievents, fieldOfView} = simState;

    if (window.location.hash) {
      const system = JSON.parse(window.decompressFromEncodedURIComponent(window.location.hash.substr(1)));
      simState.playback = system;
    }

    // renderUniverse(simState);

    function renderUniverse({universe, positions, colors, sizes, fieldOfView}) {
      return render(
        <root>
          <camera proxy={true}
                  position={[0, 5, 0]}
                  lookAt={[0, 0, 0]}
                  fov={fieldOfView}
                  up={[0, 1, 0]} />
          <cartesian range={[[-1, 1], [-1, 1], [-1, 1]]}
                     scale={[1, 1, 1]}>
            <array id="positions"
                   width={universe.length}
                   channels={3}
                   history={1}
                   data={positions} />
            <array id="colors"
                   width={universe.length}
                   channels={4}
                   data={colors} />
            <array id="sizes"
                   width={universe.length}
                   channels={1}
                   data={sizes} />
            <point points="<<<" colors="<<" sizes="<" shape="circle" blending="mult" opacity={0.9}/>
          </cartesian>
        </root>
      );
    }

    if (window.location.search === '?nointro') document.querySelector('notice').classList.add('no-intro');

    let given, needsStart;

    const madeWithEl = document.querySelector('made-with');
    madeWithEl.addEventListener('click', madeWithGiven);

    setTimeout(madeWithGiven, 1000 * 7);
    // setTimeout(madeWithGiven, 0);

    function madeWithGiven() {
      given = true;
      if (needsStart) needsStart();
      madeWithEl.classList.add('given');
    }

    const updateWidth = {
      'width'() { return universe.length; }
    };

    module.exports = {
      editorPanel: false,
      plugins: ['core', 'cursor', 'controls'],
      callback: start,
      callback: jsxboxCallback,
      camera: {far: 9e64},
      controls: [
        [['A'], '+left', '-left'],
        [['D'], '+right', '-right'],
        [['W'], '+forward', '-forward'],
        [['S'], '+backward', '-backward'],
        [['Q'], '+up', '-up'],
        [['Z'], '+down', '-down'],
        [['H'], 'toggleHistory'],
        [['L'], 'lookAtTrump'],
        [['O'], 'overview'],
        [['F'], 'frontview'],
        [['V'], 'sideview'],
        [[190], 'speed+'],
        [[188], 'speed-'],
        [['0'], 'ticks+'],
        [['9'], 'ticks-'],
        [[32], 'changePlayer'],
        [[13], 'newMass'],
        [[221], 'nextMass'],
        [[219], 'prevMass']
      ],
      commands: {
        '+left': repeat => !repeat ? setBoost(-vBoost) : undefined,
        '-left': () => unsetBoost(-vBoost),
        '+right': repeat => !repeat ? setBoost(vBoost) : undefined,
        '-right': () => unsetBoost(vBoost),
        '+forward': repeat => !repeat ? setBoost(0, 0, -vBoost) : undefined,
        '-forward': () => unsetBoost(0, 0, -vBoost),
        '+backward': repeat => !repeat ? setBoost(0, 0, vBoost) : undefined,
        '-backward': () => unsetBoost(0, 0, vBoost),
        '+up': repeat => !repeat ? setBoost(0, vBoost) : undefined,
        '-up': () => unsetBoost(0, vBoost),
        '+down': repeat => !repeat ? setBoost(0, -vBoost) : undefined,
        '-down': () => unsetBoost(0, -vBoost),
        // 'lookAtTrump': () => camera.lookAtIndex = 0,
        // 'overview': () => {camera.lookAtIndex = 0; camera.positionIndex = 0; camera.targetOffset =  views.overview;},
        // 'frontview': () => {camera.lookAtIndex = 0; camera.positionIndex = 0; camera.targetOffset =  views.frontview;},
        // 'sideview': () => {camera.lookAtIndex = 0; camera.positionIndex = 0; camera.targetOffset =  views.sideview;},
        // 'lookAtTrump': () => camera.lookAt = sun,
        // 'overview': () => {camera.lookAt = sun; camera.follow = sun; camera.targetOffset =  views.overview;},
        // 'frontview': () => {camera.lookAt = sun; camera.follow = sun; camera.targetOffset =  views.frontview;},
        // 'sideview': () => {camera.lookAt = sun; camera.follow = sun; camera.targetOffset =  views.sideview;},
        'speed+': () => ++stepsPerSecond,
        'speed-': () => stepsPerSecond = Math.max(1, stepsPerSecond - 1),
        'ticks+': () => ++ticksPerStep,
        'ticks-': () => ticksPerStep = Math.max(1, ticksPerStep - 1),
        'changePlayer'() {
          unselectMass(selectedMassIndex);
          (selectedMassIndex = (selectedMassIndex + 1) % positions.length);
          selectMass(selectedMassIndex);
        },
        'toggleHistory': {
          '#positions': {
            'history'() {
              // doesn't work :(
              return 1;
            }
          }
        },
        'newMass': {
          '#positions': updateWidth,
          '#colors': updateWidth,
          '#velocities': updateWidth,
          '#sizes': updateWidth
        }
      }
    };

    function jsxboxCallback(view) {
      if (given) start(simState); // global!!
      else needsStart = () => start(simState);
    }

    function start(state) {
      needsStart = undefined; // global!!

      const {tick, universe, uievents} = state,
            view = renderUniverse(state);

      const run = createRunner(state);

      let stop = false;

      setupUI(
        document.getElementsByTagName('interface')[0],
        state,
        {
          create: ({position, velocity, mass, color}) => state.inputEvents.push(['newmass', {position: position.slice(), velocity: velocity.slice(), mass, color: color.slice()}]),
          restart: () => {
            simState = window.createSim();

            window.universe = simState.universe;
            window.positions = simState.positions;
            window.colors = simState.colors;
            window.sizes = simState.sizes;
            window.eevents = simState.eevents;
            window.uuievents = simState.uuievents;
            window.fieldOfView = simState.fieldOfView;

            view.select('#positions').set('data', positions).set('width', positions.length);
            view.select('#colors').set('data', colors).set('width', colors.length);
            // view.select('#velocities').set('data', velocities).set('width', velocities.length);
            view.select('#sizes').set('data', sizes).set('width', sizes.length);

            view.select('camera').set('fov', fieldOfView);

            start(simState);

            stop = true;
          },
          save,
          load: (system) => {
            simState = window.createSim();

            window.universe = simState.universe;
            window.positions = simState.positions;
            window.colors = simState.colors;
            window.sizes = simState.sizes;
            window.eevents = simState.eevents;
            window.uuievents = simState.uuievents;
            window.fieldOfView = simState.fieldOfView;

            view.select('#positions').set('data', positions).set('width', positions.length);
            view.select('#colors').set('data', colors).set('width', colors.length);
            // view.select('#velocities').set('data', velocities).set('width', velocities.length);
            view.select('#sizes').set('data', sizes).set('width', sizes.length);

            view.select('camera').set('fov', fieldOfView);

            simState.playback = system;

            start(simState);

            stop = true;
          },
          delete: systemIndex => {
            if (confirm('Are you sure you want to delete?')) {
              const systems = JSON.parse(localStorage['systems'] || '[]');
              systems.splice(systemIndex, 1);
              localStorage['systems'] = JSON.stringify(systems);
            }
          },
          setGravityConstant: gravityConstant => state.inputEvents.push(['gravityConstant', gravityConstant]),
          setTicksPerStep: ticksPerStep => state.inputEvents.push(['ticksPerStep', ticksPerStep]),
          setStepsPerSecond: stepsPerSecond => state.inputEvents.push(['stepsPerSecond', stepsPerSecond]),
          setFieldOfView: fov => {
            state.inputEvents.push(['fov', fov]);
            view.select('camera').set('fov', fov)
          },
          setSaveSystemOnExit: saveOnExit => saveOnExit ? 
                                      window.addEventListener('beforeunload', save) & (localStorage ? localStorage['saveOnExit'] = 'true' : undefined) : 
                                      window.removeEventListener('beforeunload', save) & (localStorage ? localStorage['saveOnExit'] = 'false' : undefined)
        }
      );

      window.requestAnimationFrame(animate);

      function animate() {
        run();

        for (let i = 0; i < uievents.length; i++) {
          const event = uievents[i];

          (uuievents[event[0]] || (() => {}))(event, view, state);
        }

        uievents.splice(0);

        if (!stop) window.requestAnimationFrame(animate);
      }
    }
  </script>
</mathbox>

<universe></universe>

<interface></interface>

<made-with>
    <span>Made With</span>
    <components>
      <mathbox>Mathbox</mathbox>
      <three>THREE.js</three>
      <preact>preact</preact>
      <npm>npm</npm>
      <sublime>Sublime Text</sublime>
      Linux
      Babel
      Browserify
      Fedora
      Intel
      Google
      Soundcloud
      many others...
    </components>
</made-with>