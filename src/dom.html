<mathbox tabindex="2">
  <script type="mathbox/jsx">
    // document.body.addEventListener('touchstart', goFullScreen);

    //bad name
    function goFullScreen() {
      if (document.body.requestFullscreen) document.body.requestFullscreen();
      else if (document.body.webkitRequestFullscreen) document.body.webkitRequestFullscreen();
      else if (document.body.mozRequestFullscreen) document.body.mozRequestFullscreen();
      else if (document.body.msRequestFullscreen) document.body.msRequestFullscreen();

      document.body.removeEventListener('touchstart', goFullScreen);
    }

    let scalar = 0.10;
    const mathboxEl = document.querySelector('mathbox'),
          universeEl = document.querySelector('universe');

    mathboxEl.addEventListener('wheel', event => {
      console.log('wheel', event);
      // camera.followDistance *= 1 + (event.deltaY > 0 ? scalar : -scalar);
      // camera.followDistance = Math.max(0, camera.followDistance);
    });

    console.log({mathboxEl});

    // document.body.addEventListener('mousemove', ({clientX, clientY}) => {
    //   const width = document.body.clientWidth,
    //         height = document.body.clientHeight,
    //         x = clientX / width - 0.5,
    //         y = clientY / height - 0.5;

    //   // set(camera.targetOffset, x, y, 0);
    //   set(camera.targetLocalRotation, x * 2, y * 2, 1);
    // });

    function vnew(v) {
      return copy([0, 0, 0], v);
    }

    class Mass {
      constructor(mass, color, position = [0, 0, 0], velocity = [0, 0, 0], acceleration = [0, 0, 0], gravity = [0, 0, 0]) {
        this._sizeContainer = [];
        this.mass = mass;
        this.color = color;
        this.position = position;
        this.velocity = velocity;
        this.acceleration = acceleration;
        this.gravity = gravity;
        this.boost = [0, 0, 0];
        this.emissionCounter = 0;
        this.collisions = [];
      }

      set mass(value) { this._mass = value; this._sizeContainer[0] = Math.pow((3 / (4 * Math.PI)) * value, 1 / 3); }
      // set mass(value) { this._mass = value; this._sizeContainer[0] = 5 * Math.pow(value / Math.PI, 1 / 2); }
      get mass() { return this._mass; }

      get name() { return 'Mass'; }

      get size() { return this._sizeContainer[0]; }
      get collisionSize() { return this.size; }
      // get size() { return this.mass; }
      // get size() { return 800 * Math.log2(this.mass + 1); }

      positionHalfTick(ticksPerStep) {
        const {position: p, velocity: v} = this;
        add(p, p, div(dd, div(dd, v, ticksPerStep), 2));
      }

      velocityTick(ticksPerStep) {
        const {
          velocity: v,
          acceleration: a,
          gravity: g
        } = this;

        add(v, v, div(dd, add(dd, a, g), ticksPerStep));
      }
    }

    class Trump extends Mass {
      constructor (...args) {
        super(...args);
        this.color = [2, 2, 0, 0.05];
      }
      get name() { return '<trump>TRUMP</trump>'; }
      get size() { return 0; }
      get collisionSize() { return super.size; }
    }

    class Observer extends Mass {
      get name() { return this._name || 'Observer'; }
      set name(value) { this._name = value; }
    }

    class Tweet extends Mass {
      constructor(...args) {
        super(...args);

        this.likes = 0;
        this.retweets = 0;
        this.followers = 0; // only the oldTweets tweet should use this (new class?)
      }
      get name() { return 'Tweet'; }
    }

    class OldTweets extends Tweet {
      get name() { return 'Tweet\'s of <trump>TRUMP</trump>\'s Past'; }
    }

    class TweetSpawn extends Mass { }

    class Like extends TweetSpawn {
      get name() { return 'Like'; }
    }

    class ReTweet extends TweetSpawn {
      get name() { return 'Retweet'; }
    }

    class Follower extends TweetSpawn {
      get name() { return 'New Follower'; }
    }

    class Media extends Mass {
      constructor(mediaName, ...args) {
        super(...args);
        this.mediaName = mediaName;
      }

      get name() { return this.mediaName; }
    };

    class Emission extends Mass {
      get name() { return 'Emission'; }
    }

    const COLORS = {
      observer: [0, 0, 2, 1],
      tweet: [0, 1, 1.2, 2],
      retweet: [25 / 128, 207 / 128, 134 / 128, 2],
      like: [190 / 128, 25 / 128, 49 / 128, 2],
      follower: [0 / 128, 25 / 128, 256 / 128, 2],
      cnn: [2, 2, 2, 1]
    };

    const ORBIT_PARAMETERS = {
      'observer': {
        p: (tp, tv) => [tp[0], tp[1], tp[2] + 5],
        v: (tp, tv) => [tv[0] + 1, tv[1], tv[2]]
      },
      'oldTweets': {
        p: (tp, tv) => [tp[0] - 30, tp[1] - 30, tp[2]],
        v: (tp, tv) => [tv[0] + 1, tv[1], tv[2] + -1]
      },
      'tweet': {
        p: (tp, tv) => [tp[0], tp[1], tp[2] + 450],
        v: (tp, tv) => [525, 0, 0]
      },
      'media': {
        p: (tp, tv) => [tp[0] + 70, tp[1] + 40, tp[2] + 450],
        v: (tp, tv) => [525, 0, 0]
      }
    };

    const eevents = {
      // external
      'newmass': newMass,
      'observer+': addObserver,
      'observer-': removeObserver,
      'tweet': addTweet,
      'like': addLike,
      'retweet': addRetweet,
      'follower-': event => {}, //?
      'follower': addFollower,

      'follower+': incrementFollowers,
      'like+': incrementLikes,
      'retweet+': incrementRetweets,

      // controls
      '+xn': event => setBoost(-vBoost),
      '-xn': event => unsetBoost(-vBoost),
      '+xp': event => setBoost(vBoost),
      '-xp': event => unsetBoost(vBoost),
      '+yn': event => setBoost(0, -vBoost),
      '-yn': event => unsetBoost(0, -vBoost),
      '+yp': event => setBoost(0, vBoost),
      '-yp': event => unsetBoost(0, vBoost),
      '+zn': event => setBoost(0, 0, -vBoost),
      '-zn': event => unsetBoost(0, 0, -vBoost),
      '+zp': event => setBoost(0, 0, vBoost),
      '-zp': event => unsetBoost(0, 0, vBoost),

      // internal
      'emission': emission,
      'absorbed': absorbed,
      'oldTweets': addOldTweets,
      'poof': poof
    };

    const uuievents = {
      // 'connected': () => noticeEl.classList.add('connected'),
      // 'tweet': event => trumpTweetEl.classList.remove('show'),
      // 'absorbed': event => absorbedEl.classList.remove('show'),
      // 'absorbedBy': event => absorbedByEl.classList.remove('show'),
      // 'poof': event => poofEl.classList.remove('show'),
      'newmass': (event, view) => {
        view.select('#positions').set('width', positions.length);
        view.select('#colors').set('width', colors.length);
        view.select('#sizes').set('width', sizes.length);
      },
      'log': ([log, ...args]) => console.log('log', ...args)
    };

    const views = {
      'overview': [0, 1, 0],
      'frontview': [0, 0, 1],
      'sideview': [-1, 0, 0]
    };


    const sun = new Mass(1000000, [255, 255, 0, 255]),
          universe = [sun],
          tweets = [],
          tweetMap = {},
          tweetSpawn = [],
          spawningTweets = new Set(),
          media = [],
          observers = [],
          emissions = [],
          boostings = [],
          events = [],
          uievents = [];

    let oldTweets;

    let pendingTweetSpawn = 0;

    const MAX_TWEET_SPAWN = 75,
          MAX_OBSERVERS = 51,
          MAX_TWEET_SPAWN_AGE = 60 * 5,
          MAX_EMISSION_AGE = 60 * 5;

    const EMISSION_RATE = 10,
          EMISSION_SCALE_FACTOR = 5;

    const vBoost = 10;

    const [
      positions,
      velocities,
      accelerations,
      gravities,
      masses,
      sizes,
      colors
    ] = map(universe, ['position', 'velocity', 'acceleration', 'gravity', 'mass', 'size', 'color']);

    function map(list, properties) {
      return properties.map(p => list.map(item => item[p]));
    }




    function addMass(newMass) {
      const {position, velocity, acceleration, gravity, mass, size, color} = newMass;

      newMass.created = currentTick;

      universe.push(newMass);
      positions.push(position);
      velocities.push(velocity);
      accelerations.push(acceleration);
      gravities.push(gravity);
      masses.push(mass);
      sizes.push(size);
      colors.push(color);

      uievents.push(['newmass']);

      console.log(sizes);

      return newMass;
    }

    function newMass([_, {position: p, velocity: v, mass, color}]) {
      console.log('newmass', p, v, mass, color);
      const {position: tp, velocity: tv} = sun;
      const newMass = addMass(new Mass(mass, color.slice(), [tp[0] + p[0], tp[1] + p[1], tp[2] + p[2]], [tv[0] + v[0], tv[1] + v[1], tv[2] + v[2]]));

      setStat('masses', universe.length);
    }

    let totalObserverCount = 0;
    function addObserver([_, totalConnected]) {
      if (observers.length < MAX_OBSERVERS) {
        const {position: tp, velocity: tv} = sun;
        const observer = addMass(new Observer(1000, COLORS.observer.slice(), ORBIT_PARAMETERS.observer.p(tp, tv), ORBIT_PARAMETERS.observer.v(tp, tv)));

        observer.name = `Observer ${totalObserverCount++}`;

        observers.push(observer);
      }
      else {
        const observer = observers[Math.round(Math.random() * (observers.length - 1))];
        observer.name = `Observer ${totalObserverCount++}`;
        observer.mass++;
      }

      setStat('totalSouls', totalConnected);
    }

    function removeObserver([_, totalConnected]) {
      setStat('totalSouls', totalConnected);
    }

    function addOldTweets(event) {
      console.log('adding old tweets', event);
      const {position: tp, velocity: tv} = sun;
      oldTweets = new OldTweets((oldTweets || {mass: 10}).mass, [0, 1, 1.2, 1], ORBIT_PARAMETERS.oldTweets.p(tp, tv), ORBIT_PARAMETERS.oldTweets.v(tp, tv));

      addMass(oldTweets);
      tweets.push(oldTweets);
    }

    function addTweet(event) {
      // this should be calculated based on current sun mass (and, maybe, positions/velocities of orbiting masses?)
      const {position: tp, velocity: tv} = sun;

      const tweet = new Tweet(500, COLORS.tweet,
                                   ORBIT_PARAMETERS.tweet.p(tp, tv),
                                   ORBIT_PARAMETERS.tweet.v(tp, tv)),
            cnn = new Media('CNN', 5, COLORS.cnn,
                                      ORBIT_PARAMETERS.media.p(tp, tv),
                                      ORBIT_PARAMETERS.media.v(tp, tv));

      tweet.tweetID = event[1] || 'fake';

      addMass(tweet);
      addMass(cnn);

      tweets.push(tweet);
      media.push(cnn);

      tweetMap[tweet.tweetID] = tweet;

      uievents.push(['tweet']);
    }

    function addRetweet(event) {
      addTweetSpawn(tweetMap[event[1]] || oldTweets, ReTweet, 1, COLORS.retweet);
    }

    function addLike(event) {
      addTweetSpawn(tweetMap[event[1]] || oldTweets, Like, 1, COLORS.like);
    }

    function addFollower(event) {
      addTweetSpawn(oldTweets, Follower, 1, COLORS.follower);
    }

    const spread = 700;

    function addTweetSpawn(tweet, constructor, mass, color) {
      if (!tweet) throw new Error('No tweet!!!!!!@!');

      const {position: p} = tweet,
            {position: tp, velocity: tv} = universe[0];

      const x = 20;

      const d = [0, 0, 0];

      sub(d, tp, p);

      const m = magnitude(d);

      const position = [p[0] + d[0] / m * (50 + spread * Math.random())
                       ,p[1] + d[1] / m * (50 + spread * Math.random())
                       ,p[2] + d[2] / m * (50 + spread * Math.random())];

      const spawn = new constructor(mass, color, position,
                                  [tv[0] + d[0]/x, tv[1] + d[1]/x, tv[2] + d[2]/x]);
      tweet.mass += spawn.mass;

      addMass(spawn);
      tweetSpawn.push(spawn);
      pendingTweetSpawn--;
    }

    function emission ([_, mass, emissionDirection]) {
      const {position: p, velocity: v} = mass;

      const emission = mass.mass * 0.01 / ticksPerStep;

      scale(dd, emissionDirection, mass.collisionSize / 30); // why does this need ~30 here?

      const e = addMass(new Emission(emission, COLORS.observer, add([0, 0, 0], mass.position, dd), add([0, 0, 0], newv(mass.velocity), scale(dd, dd, EMISSION_SCALE_FACTOR))));

      emissions.push(e);
    }

    function absorbed(event) {
      uievents.push(event);
    }

    function incrementLikes([_, id, likes]) {
      const tweet = tweetMap[id] || oldTweets;
      tweet.likes += likes;
      spawningTweets.add(tweet);
    }

    function incrementRetweets([_, id]) {
      const tweet = tweetMap[id] || oldTweets;
      tweet.retweets++;
      spawningTweets.add(tweet);
    }

    function incrementFollowers([_, followers]) {
      oldTweets.followers += followers;
    }

    function poof([_, mass]) {
      if (mass instanceof TweetSpawn) {
        tweetSpawn.splice(tweetSpawn.indexOf(mass), 1);
      }
      else if (mass instanceof Tweet) {
        tweets.splice(tweets.indexOf(mass), 1);
        delete tweetMap[mass.tweetID];
      }
      else if (mass instanceof Observer) {
        observers.splice(observers.indexOf(mass), 1);
      }

      const index = universe.indexOf(mass); // annoying lookup
      console.log('poof removing', index);
      universe.splice(index, 1);
      positions.splice(index, 1);
      velocities.splice(index, 1);
      accelerations.splice(index, 1);
      gravities.splice(index, 1);
      masses.splice(index, 1);
      sizes.splice(index, 1);
      colors.splice(index, 1);
    }

    function setBoost(x = 0, y = 0, z = 0) {
      console.log('setBoost', x, y, z);
      const mass = sun,
            {boost} = mass;

      add(boost, boost, [x, y, z]);

      console.log(boost);

      if (boostings.indexOf(mass) === -1) boostings.push(mass); // more efficient way?
    }

    function unsetBoost(x = 0, y = 0, z = 0) {
      console.log('unsetBoost', x, y, z);
      const mass = sun,
            {acceleration, boost} = mass;

      set(acceleration, 0, 0, 0);
      sub(boost, boost, [x, y, z]);

      console.log(boost);

      if (boost[0] === 0 && boost[1] === 0 && boost[2] === 0) {
        console.log('removing');
        const index = boostings.indexOf(mass);
        if (index > -1) boostings.splice(index, 1);
      }
    }


    let trumpScaleFactor = 5;
    <root>
      <camera proxy={true}
              position={[0, 5, 0]}
              lookAt={[0, 0, 0]}
              fov={120}
              up={[0, 1, 0]} />
      <cartesian range={[[-1, 1], [-1, 1], [-1, 1]]}
                 scale={[1, 1, 1]}>
        <array id="positions"
               width={universe.length}
               channels={3}
               history={1}
               data={positions} />
        <array id="colors"
               width={universe.length}
               channels={4}
               data={colors} />
        <array id="sizes"
               width={universe.length}
               channels={1}
               data={sizes} />
        <point points="<<<" colors="<<" sizes="<" shape="circle" blending="mult" opacity={0.9}/>
      </cartesian>
    </root>

    const speedlimit = 300000;
    const pv1 = [0, 0, 0],
          pv2 = [0, 0, 0],
          oldp1 = [0, 0, 0],
          oldp2 = [0, 0, 0],
          dd = [0, 0, 0];


    const collisionList = []; // where should this go?
    let collisionIIndex = 0;

    let /*ticksPerSecond = 60,*/
        ticksPerStep = 60,
        stepsPerSecond = 1;


    let currentTick = 0;
    function tick() {
      currentTick++;

      updateBoosts();
      updateEmissions();
      updateTweetSpawn();
      positionHalfTick();
      updateGravities();
      updateVelocities();
      resolveCollisions();

      function updateBoosts() {
        boostings.forEach(mass => {
          const {boost, position: p, velocity: v} = mass,
                tp = sun.position,
                d = normalize([0, 0, 0], sub(dd, p, tp)),
                [x, y, z] = boost;

          const u = [0, 0, 1];

          const q = qFromUnitVectors(u, d);

          const r = [0, 0, 0, 0],
                i = qinv([0, 0, 0, 0], q);

          qmult(r, qmult(r, q, [0, x, y, z]), qconj(i, q));

          qunit(r, r);

          // r seems to not be right here in some cases

          if (mass.emissionCounter++ % EMISSION_RATE === 0) events.push(['emission', mass, [-r[1], -r[2], -r[3]]]);

          scale(dd, [r[1], r[2], r[3]], EMISSION_SCALE_FACTOR * mass.mass / 2);

          copy(mass.acceleration, dd);

          mass.mass -= mass.mass * 0.01 / ticksPerStep;

          if (mass.mass < 0.01) events.push(['poof', mass, i]);
        });
      }

      function updateEmissions() {
        for (let i = emissions.length - 1; i >= 0; i--) {
          const emission = emissions[i],
                {created} = emission;

          if (currentTick - created > MAX_EMISSION_AGE) {
            emissions.splice(i, 1);
            const index = universe.indexOf(emission); // annoying lookup
            universe.splice(index, 1);
            positions.splice(index, 1);
            velocities.splice(index, 1);
            accelerations.splice(index, 1);
            gravities.splice(index, 1);
            masses.splice(index, 1);
            sizes.splice(index, 1);
            colors.splice(index, 1);
          }
        }
      }

      function updateTweetSpawn() {
        const {position: tp, velocity: tv} = sun;

        for (let i = 0; i < tweetSpawn.length; i++) {
          const spawn = tweetSpawn[i],
                {mass, position: p, velocity: v, created} = spawn;

          const age = currentTick - created;
          const x = Math.max(1, ticksPerStep * 1 / Math.min(ticksPerStep * 1, age));

          sub(dd, tp, p);
          add(v, tv, (div(dd, dd, x)));

          if (age > MAX_TWEET_SPAWN_AGE) {
            const index = universe.indexOf(spawn);
            if (index === -1) {
              uievents.push(['log', '-1!', age, spawn, universe]);
            }
            else {
              collisionList.push([spawn, sun, index]);
            }
          }
        }

        resolveCollisions();

        //lots of unnecessary stuff going on here sometimes
        spawningTweets.forEach(tweet => {
          if ((tweetSpawn.length + pendingTweetSpawn) >= MAX_TWEET_SPAWN) return false;

          if (tweet.likes > 0 && Math.random() > 0.5) {
            tweet.likes--;
            events.push(['like', tweet.tweetID]);
            pendingTweetSpawn++;
          }

          if ((tweetSpawn.length + pendingTweetSpawn) >= MAX_TWEET_SPAWN) return false;

          if (tweet.retweets > 0 && Math.random() > 0.5) {
            tweet.retweets--;
            events.push(['retweet', tweet.tweetID]);
            pendingTweetSpawn++;
          }

          if ((tweetSpawn.length + pendingTweetSpawn) >= MAX_TWEET_SPAWN) return false;

          if (tweet.followers > 0 && Math.random() > 0.5) {
            tweet.followers--;
            events.push(['follower']);
            pendingTweetSpawn++;
          }
        });
      }

      function positionHalfTick() {
        for (let i = 0; i < universe.length; i++) {
          const mass = universe[i];

          mass.positionHalfTick(ticksPerStep);
          set(mass.gravity, 0, 0, 0);
        }
      }

      // can be optimized quite a bit? ?
      function updateGravities() {
        for (let i = 0; i < universe.length; i++) updatePairs(i);
      }

      function updatePairs(i) {
        const {
          position: p1,
          velocity: v1,
          acceleration: a1,
          gravity: g1,
          mass: m1,
          collisionSize: s1,
          collisions
        } = universe[i];

        for (let j = i + 1; j < universe.length; j++) updatePair(p1, v1, a1, g1, m1, s1, i, j, collisions); //

        if (collisions.length > 0) {
          collisionList.push(collisions[0]);
          if (collisions.length > 1) console.log('+1', collisions);
          collisions.splice(0);
        }

        // F = ma ... a = F/m
        div(g1, g1, m1);
      }

      function updatePair(p1, v1, a1, g1, m1, s1, i, j, collisions) {
        const {
          position: p2,
          velocity: v2,
          acceleration: a2,
          mass: m2,
          collisionSize: s2,
          gravity: g2
        } = universe[j];

        sub(dd, p1, p2);

        const distance = magnitude(dd),
              t = -distance / (speedlimit * speedlimit),
              o = t / ticksPerStep;

        updatePositionAndGravity(o, a1, a2, v1, v2, p1, p2, g1, g2, m1 * m2);

        handleCollision(s1, s2, m1, m2, distance, i, j, collisionList, collisions);
      }

      function updatePositionAndGravity(o, a1, a2, v1, v2, p1, p2, g1, g2, m) {
        updatePosition(oldp1, o, a1, v1, p1);
        updatePosition(oldp2, o, a2, v2, p2);

        sub(pv1, oldp1, p2);
        sub(pv2, oldp2, p1);

        const d1 = dot(pv1, pv1),
              d2 = dot(pv2, pv2);

        updateGravity(d1, pv1, g2, m);
        updateGravity(d2, pv2, g1, m);
      }

      function updatePosition(oldp, o, a, v, p) {
        return add(oldp, p, scale(dd, add(dd, v, scale(dd, add(dd, v, scale(dd, a, o)), 0.5)), o));
      }

      function updateGravity(d, pv, g, m) {
        if (d > 0) add(g, g, scale(dd, pv, 6.67408e-7 * m / d));
      }

      function handleCollision(s1, s2, m1, m2, distance, i, j, collisionList, collisions) {
        if (collisions.length === 0) {
          // const threshold = Math.sqrt(s1 / 4 + s2 / 4) / 4;
          const threshold = (s1 + s2) / 75;
          // const threshold = Math.sqrt(s1 / 8 + s2 / 8) / 8;
          // const threshold = s1[0] / 10 + s2[0] / 10;
          // const threshold = (s1[0] + s2[0]) / 2;
          if (distance < threshold) { // better ordering of checks?
            console.log(distance, threshold, s1, s2);
            if (m1 <= m2) {
              //wtf is this
              collisions.push([universe[i], universe[j], i, j]);
            }
            else {
              universe[j].collisions.push([universe[j], universe[i], j, i]);
            }
          }
        }
      }

      function updateVelocities() {
        universe.forEach(updateMassVelocityAndPartialPosition);
      }

      function updateMassVelocityAndPartialPosition(mass) {
        mass.velocityTick(ticksPerStep);
        mass.positionHalfTick(ticksPerStep);
      }

      function resolveCollisions() {
        for (let i = collisionList.length - 1; i >= 0; i--) {
          console.log('collision', collisionList[i]);
          const [smallerMass, greaterMass] = collisionList[i];

          greaterMass.mass += smallerMass.mass;

          const ratio = smallerMass.mass / greaterMass.mass; // 0?

          greaterMass.color[0] = (1 - ratio) * greaterMass.color[0] + ratio * smallerMass.color[0];
          greaterMass.color[1] = (1 - ratio) * greaterMass.color[1] + ratio * smallerMass.color[1];
          greaterMass.color[2] = (1 - ratio) * greaterMass.color[2] + ratio * smallerMass.color[2];

          // greaterMass.color[0] = (greaterMass.color[0] + smallerMass.color[0]) / 2;
          // greaterMass.color[1] = (greaterMass.color[1] + smallerMass.color[1]) / 2;
          // greaterMass.color[2] = (greaterMass.color[2] + smallerMass.color[2]) / 2;


          div(greaterMass.velocity,
            add(greaterMass.velocity,
              scale(greaterMass.velocity,
                greaterMass.velocity,
                greaterMass.mass),
              scale(dd, smallerMass.velocity, smallerMass.mass)),
            greaterMass.mass + smallerMass.mass);
        }

        for (let i = collisionList.length - 1; i >= 0; i--) {
          const [smallerMass, greaterMass, smallerIndex, greaterIndex] = collisionList[i];

          if (smallerMass instanceof TweetSpawn) {
            tweetSpawn.splice(tweetSpawn.indexOf(smallerMass), 1);
          }
          else if (smallerMass instanceof Tweet) {
            tweets.splice(tweets.indexOf(smallerMass), 1);
            delete tweetMap[smallerMass.tweetID];

            if (smallerMass instanceof OldTweets) events.push(['oldTweets']);
          }
          else if (smallerMass instanceof Observer) {
            observers.splice(observers.indexOf(smallerMass), 1);
          }
          else if (smallerMass instanceof Emission) {
            emissions.splice(emissions.indexOf(smallerMass), 1);
          }

          incrementStat(smallerMass.constructor.name, 'absorbedBy', greaterMass.constructor.name);

          if (smallerMass instanceof Tweet ||
              smallerMass instanceof Media ||
              smallerMass instanceof Trump ||
              greaterMass instanceof Tweet ||
              greaterMass instanceof Media ||
              greaterMass instanceof Trump) {
            events.push(['absorbed', smallerMass.name, greaterMass.name]);
          }

          sizes[greaterIndex] = greaterMass.size;

console.log('removing', smallerIndex);
          universe.splice(smallerIndex, 1);
          positions.splice(smallerIndex, 1);
          velocities.splice(smallerIndex, 1);
          accelerations.splice(smallerIndex, 1);
          gravities.splice(smallerIndex, 1);
          masses.splice(smallerIndex, 1);
          sizes.splice(smallerIndex, 1);
          colors.splice(smallerIndex, 1);
        }

        collisionList.splice(0);
        collisionIIndex = 0;
      }
    }


    const stats = {totalSouls: 0};
    function incrementStat(target, relation, object) {
      stats[target] = stats[target] || {};
      stats[target][relation] = stats[target][relation] || {};
      return (stats[target][relation][object] = (stats[target][relation][object] || 0) + 1);
      // return (stats[target][relation][object] = ((stats[target][relation] = (stats[target] = stats[target] || {})[relation] || {})[object] || 0) + 1);

      // stats[target][relation][object] = (stats[target][relation][object] || 0) + 1;
    }

    function setStat(target, value) {
      stats[target] = value;
    }

    let selectedMassIndex = 0, savedColor = [0, 0, 0];
    selectMass(selectedMassIndex);

    if (window.location.search === '?nointro') document.querySelector('notice').classList.add('no-intro');

    const guiUpdates = [];

    let given, needsStart;

    // stateEl.addEventListener('click', stateGiven);

    // setTimeout(stateGiven, 1000 * 60);
    setTimeout(stateGiven, 0);

    function stateGiven() {
      given = true;
      // stateEl.classList.add('given');
      // noticeEl.classList.add('given');
      if (needsStart) needsStart();
    }



    module.exports = {
      editorPanel: false,
      plugins: ['core', 'cursor', 'controls'],
      callback: start,
      callback: jsxboxCallback,
      camera: {far: 9e64},
      controls: [
        [['A'], '+left', '-left'],
        [['D'], '+right', '-right'],
        [['W'], '+forward', '-forward'],
        [['S'], '+backward', '-backward'],
        [['Q'], '+up', '-up'],
        [['Z'], '+down', '-down'],
        [['H'], 'toggleHistory'],
        [['T'], 'fakeTweet'],
        [['R'], 'fakeRetweet'],
        [['K'], 'fakeLike'],
        [['L'], 'lookAtTrump'],
        [['O'], 'overview'],
        [['F'], 'frontview'],
        [['V'], 'sideview'],
        [[190], 'speed+'],
        [[188], 'speed-'],
        [['0'], 'ticks+'],
        [['9'], 'ticks-'],
        [[32], 'changePlayer'],
        [[13], 'newMass'],
        [[221], 'nextMass'],
        [[219], 'prevMass']
      ],
      commands: {
        '+left': repeat => !repeat ? setBoost(-vBoost) : undefined,
        '-left': () => unsetBoost(-vBoost),
        '+right': repeat => !repeat ? setBoost(vBoost) : undefined,
        '-right': () => unsetBoost(vBoost),
        '+forward': repeat => !repeat ? setBoost(0, 0, -vBoost) : undefined,
        '-forward': () => unsetBoost(0, 0, -vBoost),
        '+backward': repeat => !repeat ? setBoost(0, 0, vBoost) : undefined,
        '-backward': () => unsetBoost(0, 0, vBoost),
        '+up': repeat => !repeat ? setBoost(0, vBoost) : undefined,
        '-up': () => unsetBoost(0, vBoost),
        '+down': repeat => !repeat ? setBoost(0, -vBoost) : undefined,
        '-down': () => unsetBoost(0, -vBoost),
        // 'lookAtTrump': () => camera.lookAtIndex = 0,
        // 'overview': () => {camera.lookAtIndex = 0; camera.positionIndex = 0; camera.targetOffset =  views.overview;},
        // 'frontview': () => {camera.lookAtIndex = 0; camera.positionIndex = 0; camera.targetOffset =  views.frontview;},
        // 'sideview': () => {camera.lookAtIndex = 0; camera.positionIndex = 0; camera.targetOffset =  views.sideview;},
        // 'lookAtTrump': () => camera.lookAt = sun,
        // 'overview': () => {camera.lookAt = sun; camera.follow = sun; camera.targetOffset =  views.overview;},
        // 'frontview': () => {camera.lookAt = sun; camera.follow = sun; camera.targetOffset =  views.frontview;},
        // 'sideview': () => {camera.lookAt = sun; camera.follow = sun; camera.targetOffset =  views.sideview;},
        'speed+': () => ++stepsPerSecond,
        'speed-': () => stepsPerSecond = Math.max(1, stepsPerSecond - 1),
        'ticks+': () => ++ticksPerStep,
        'ticks-': () => ticksPerStep = Math.max(1, ticksPerStep - 1),
        'changePlayer'() {
          unselectMass(selectedMassIndex);
          (selectedMassIndex = (selectedMassIndex + 1) % positions.length);
          selectMass(selectedMassIndex);
        },
        'toggleHistory': {
          '#positions': {
            'history'() {
              // doesn't work :(
              return 1;
            }
          }
        },
        'fakeTweet': {
          '#positions': {
            'width'() {
              events.push(['tweet']);
              return universe.length;
            }
          },
          '#colors': {
            'width'() { return universe.length; }
          },
          '#velocities': {
            'width'() { return universe.length; }
          },
          '#sizes': {
            'width'() { return universe.length; }
          }
        },
        'fakeRetweet': {
          '#positions': {
            'width'() {
              events.push(['retweet', 'fake']);
              return universe.length;
            }
          },
          '#colors': {
            'width'() { return universe.length; }
          },
          '#velocities': {
            'width'() { return universe.length; }
          },
          '#sizes': {
            'width'() { return universe.length; }
          }
        },
        'fakeLike': {
          '#positions': {
            'width'() {
              events.push(['like', 'fake']);
              return universe.length;
            }
          },
          '#colors': {
            'width'() { return universe.length; }
          },
          '#velocities': {
            'width'() { return universe.length; }
          },
          '#sizes': {
            'width'() { return universe.length; }
          }
        },
        'newMass': {
          '#positions': {
            'width'() {
              events.push(['observer+']);
              return universe.length;
            }
          },
          '#colors': {
            'width'() { return universe.length; }
          },
          '#velocities': {
            'width'() { return universe.length; }
          },
          '#sizes': {
            'width'() { return universe.length; }
          }
        },
        'prevMass': () => {
          centeredMassIndex = (centeredMassIndex === 0 ? universe.length : centeredMassIndex) - 1
          // nextFollow();
          // const index = universe.indexOf(camera.follow);

          // camera.follow =

          // return camera.positionIndex === 0 ? camera.positionIndex = universe.length - 1 : camera.positionIndex--;
        },
        'nextMass': () => {
          centeredMassIndex = (centeredMassIndex + 1) % universe.length;
          // previousFollow();
          // return camera.positionIndex = (camera.positionIndex + 1) % universe.length;
        }
      }
    };

    function getLargestMass() {
      let largest = universe[0];
      for (let i = 1; i < universe.length; i++) {
        const mass = universe[i];
        if (mass.mass > largest.mass) largest = mass;
      }
      return largest;
    }

    function centerOnSun() {
      const {position: tp} = sun;
      for (let i = universe.length - 1; i >= 0; i--) {
        const {position: p} = universe[i];
        sub(p, p, tp);
      }
    }

    function centerOn(msss) {
      const {position: tp} = msss;
      for (let i = universe.length - 1; i >= 0; i--) {
        const {position: p} = universe[i];
        sub(p, p, tp);
      }
    }

    class Clock {
      constructor(ticksPerStep) {
        this.ticksPerStep = ticksPerStep;
        this.startTime = this.currentTime;
      }

      get currentTime() { return new Date().getTime(); }

      ticksTo(time) {
        const dt = time - this.startTime;
        return Math.floor((dt / 1000) * ticksPerStep);
      }
    }

    function jsxboxCallback(view) {
      if (given) start(view); // global!!
      else needsStart = () => start(view);
    }

    function start(view) {
      needsStart = undefined; // global!!

      const run = runner(universe, new Clock());

      window.requestAnimationFrame(animate);

      setupUI(document.getElementsByTagName('ui')[0], 'state', {create: ({position, velocity, mass, color}) => events.push(['newmass', {position, velocity, mass, color}])});

      function runner(universe, clock, maxRunTime = 1000 / 30, GUIUpdateRate = 100) {
        const {startTime} = clock;

        let currentTick = 0,
            lastGUIUpdate = 0,
            currentTime;

        return (runTime = clock.currentTime) => {
          const t = clock.ticksTo(runTime);

          while (currentTick < t && ((currentTime = clock.currentTime) - runTime) < maxRunTime) {
            handleEvents();
            tick();
            currentTick++;
          }

          centerOn(universe[0]);
          // centerOn(getLargestMass());

          // universeEl.innerText = JSON.stringify(universe, (key, value) => Array.isArray(value) ? `[${value.join(', ')}]` : value, 2);
          // universeEl.innerText = JSON.stringify(universe);
        };

        function handleEvents() {
          for (let i = 0; i < events.length; i++) {
            const event = events[i];

            (eevents[event[0]] || defaultHandler(event))(event, view);
          }

          events.splice(0);
        }

        function defaultHandler(event) {
          console.log(`No eevents ${event[0]}!`)
          return emptyFn;
        }

        function emptyFn() {}
      }


      // function runner(universe, startTime = new Date().getTime(), maxRunTime = 1000 / 10, GUIUpdateRate = 100) {
      //   let currentTick = 0,
      //       lastGUIUpdate = 0;

      //   return (runTime = new Date().getTime()) => {
      //     const dt = runTime - startTime,
      //           t = Math.floor((dt / 1000) * ticksPerStep);

      //     centerOnSun();
      //     let currentTime;
      //     while (currentTick < t && ((currentTime = new Date().getTime()) - runTime) < maxRunTime) {
      //       handleEvents();
      //       tick();
      //       currentTick++;
      //     }

      //     if ((currentTime - lastGUIUpdate) > 100) {
      //       updateMassesGUI();
      //       lastGUIUpdate = currentTime;
      //     }

      //     if (t - currentTick > 10) {
      //       catchUpQuantityEl.parentElement.style.display = 'block';
      //       catchUpQuantityEl.innerHTML = currentTick - t;
      //     }
      //     else {
      //       catchUpQuantityEl.parentElement.style.display = 'none';
      //     }
      //   };

      //   function handleEvents() {
      //     for (let i = 0; i < events.length; i++) {
      //       const event = events[i];

      //       (eevents[event[0]] || defaultHandler(event))(event, view);
      //     }

      //     events.splice(0);
      //   }

      //   function defaultHandler(event) {
      //     console.log(`No eevents ${event[0]}!`)
      //     return emptyFn;
      //   }

      //   function emptyFn() {}
      // }

      function animate() {
        run();

        for (let i = 0; i < uievents.length; i++) {
          const event = uievents[i];

          (uuievents[event[0]] || (() => {}))(event, view);
        }

        // for (let i = 0; i < uievents.length; i++) {
        //   const [name, ...args] = uievents[i];

        //   if (name === 'tweet') trumpTweetEl.classList.add('show');
        //   else if (name === 'absorbed') {
        //     const [absorbed, by] = args;

        //     absorbedEl.classList.add('show');
        //     absorbedNameEl.innerHTML = absorbed;
        //     absorbedByNameEl.innerHTML = by;
        //   }
        //   else if (name === 'absorbedBy') {
        //     const [by] = args;

        //     absorbedByEl.classList.add('show');
        //     absorbedByByNameEl.innerHTML = by;
        //   }
        //   else if (name === 'poof') {
        //     const [poof, mass] = args;

        //     poofEl.classList.add('show');
        //   }
        // }

        uievents.splice(0);

        window.requestAnimationFrame(animate);
      }
    }

    function newv (s) {
      return copy([0, 0, 0], s);
    }

    function set (r, x, y, z) {
      r[0] = x;
      r[1] = y;
      r[2] = z;
      return r;
    }

    function copy (r, s) {
      r[0] = s[0];
      r[1] = s[1];
      r[2] = s[2];
      return r;
    }

    function add (r, u, v) {
      r[0] = u[0] + v[0];
      r[1] = u[1] + v[1];
      r[2] = u[2] + v[2];
      return r;
    }

    function sub (r, u, v) {
      r[0] = u[0] - v[0];
      r[1] = u[1] - v[1];
      r[2] = u[2] - v[2];
      return r;
    }

    function scale (r, v, s) {
      r[0] = v[0] * s;
      r[1] = v[1] * s;
      r[2] = v[2] * s;
      return r;
    }

    function div (r, v, d) {
      if (d === 0) return copy(r, v);
      r[0] = v[0] / d;
      r[1] = v[1] / d;
      r[2] = v[2] / d;
      return r;
    }

    function cross (r, u, v) {
      r[0] = u[1] * v[2] - u[2] * v[1];
      r[1] = u[2] * v[0] - u[0] * v[2];
      r[2] = u[0] * v[1] - u[1] * v[0];
      return r;
    }

    function dot (u, v) {
      return u[0] * v[0] + u[1] * v[1] + u[2] * v[2];
    }

    function magnitude(v) {
      return Math.sqrt(v[0] * v[0] +
                       v[1] * v[1] +
                       v[2] * v[2]);
    }

    function normalize(r, v) {
      return div(r, v, magnitude(v));
    }

    // http://lolengine.net/blog/2013/09/18/beautiful-maths-quaternion-from-vectors
    function qFromVectors(u, v) {
      cross(dd, u, v);
      const q = [dot(u, v), dd[0], dd[1], dd[2]];
      q[0] += qnorm(q);
      return qunit(q, q);
    }

    // http://web.archive.org/web/20161105145605/http://lolengine.net/blog/2014/02/24/quaternion-from-two-vectors-final
    function qFromVectors2(u, v) {
      const n = Math.sqrt(dot(u, u) * dot(v, v)),
            r = n + dot(u, v);

      if (r < 1e-6) { // why this value?!
        console.log('small value', r);
        if (Math.abs(dd[0]) > Math.abs(dd[2])) return qunit(q, [0, -dd[1], dd[2], 0]);
        else return qunit(q, [0, 0, -dd[2], dd[1]]);
      }
      else {
        cross(dd, u, v);
        const q = [r, dd[0], dd[1], dd[2]];

        return qunit(q, q);
      }
    }

    function qFromUnitVectors2(u, v) {
      const r = 1 + dot(u, v);

      if (r < 1e-6) { // why this value?!
        console.log('small value', r);
        if (Math.abs(dd[0]) > Math.abs(dd[2])) return qunit(q, [0, -dd[1], dd[2], 0]);
        else return qunit(q, [0, 0, -dd[2], dd[1]]);
      }
      else {
        cross(dd, u, v);
        const q = [r, dd[0], dd[1], dd[2]];

        return qunit(q, q);
      }
    }

    function qFromVectors2(u, v) {
      cross(dd, u, v);
      const q = [1 + dot(u, v), dd[0], dd[1], dd[2]];
      return qunit(q, q);
    }

    // http://lolengine.net/blog/2013/09/18/beautiful-maths-quaternion-from-vectors
    function qFromUnitVectors(u, v) {
      const m = Math.sqrt(2 + 2 * dot(u, v));
      div(dd, cross(dd, u, v), m);
      return [m/2, dd[0], dd[1], dd[2]];
    }


    //http://mathworld.wolfram.com/Quaternion.html
    function qmult(r, q1, q2) {

      const v1 = [q1[1], q1[2], q1[3]],
            v2 = [q2[1], q2[2], q2[3]],
            s1 = scale([0, 0, 0], v2, q1[0]),
            s2 = scale([0, 0, 0], v1, q2[0]);

      add(dd, s1, add(dd, s2, cross(dd, v1, v2)));

      r[0] = q1[0] * q2[0] - dot(v1, v2);
      r[1] = dd[0];
      r[2] = dd[1];
      r[3] = dd[2];

      return r;
    }

    function qconj(r, q) {
      r[0] = q[0];
      r[1] = -q[1];
      r[2] = -q[2];
      r[3] = -q[3];

      return r;
    }

    // don't call with d = 0
    function qdiv(r, q, d) {
      r[0] = q[0] / d;
      r[1] = q[1] / d;
      r[2] = q[2] / d;
      r[3] = q[3] / d;

      return r;
    }

    function qnorm(q) {
      return Math.sqrt(q[0] * q[0] +
                       q[1] * q[1] +
                       q[2] * q[2] +
                       q[3] * q[3]);
    }

    // assumes unit q?
    // function qinv(r, q) {
    //   const s = 1 / (q[0] * q[0] + q[1] * q[1] + q[2] * q[2] + q[3] * q[3]);

    //   r[0] = q[0] * s
    //   r[1] = -q[1] * s
    //   r[2] = -q[2] * s
    //   r[3] = -q[3] * s

    //   return r;
    // }

    function qinv(r, q) {
      const n = qnorm(q);
      return qdiv(r, qconj(r, q), n * n);
    }

    function qunit(r, q) {
      return qdiv(r, q, qnorm(q));
    }



    // might want in the future, saves typing
    function randomMass() {
      addMass(new Mass(1, [255, 255, 0, 1], [universe[0].position[0] + Math.random() * 5000 - 2500, universe[0].position[1] + Math.random() * 5000 - 2500, universe[0].position[2] + Math.random() * 5000 - 2500], [Math.random() * 600 - 300, Math.random() * 600 - 300, Math.random() * 600 - 300]));
    }

    function unselectMass(selectedMassIndex) {
      colors[selectedMassIndex][0] = savedColor[0];
      colors[selectedMassIndex][1] = savedColor[1];
      colors[selectedMassIndex][2] = savedColor[2];
    }

    function selectMass(selectedMassIndex) {
      savedColor[0] = colors[selectedMassIndex][0];
      savedColor[1] = colors[selectedMassIndex][1];
      savedColor[2] = colors[selectedMassIndex][2];
      uievents.push(['newmass']);
      // colors[selectedMassIndex][0] = 0;
      // colors[selectedMassIndex][1] = 255;
      // colors[selectedMassIndex][2] = 0;
    }
  </script>
</mathbox>

<universe></universe>

<ui></ui>

<made-with>
    <span>Made With</span>
    <components>
      <mathbox>Mathbox</mathbox>
      <three>THREE.js</three>
      <preact>preact</preact>
      <npm>npm</npm>
      <sublime>Sublime Text</sublime>
      Linux
      Babel
      Browserify
      Fedora
      Intel
      Google
      Soundcloud
      many others...
    </components>
</made-with>